# 面向对象设计原则

[柏码知识库 | 设计模式（一）面向对象设计原则](https://www.itbaima.cn/document/6386mh7anqt4tzyv)

### 1、单一职责原则

​	一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。



### 2、开闭原则

​	软件实体应当对扩展开放，对修改关闭。

一个软件实体，比如类、模块和函数应该对扩展开放，对修改关闭。其中，对扩展开放是针对提供方来说的，对修改关闭是针对调用方来说的。



	public abstract class Coder {
	
	public abstract void coding();
	
	class JavaCoder extends Coder{
	    @Override
	    public void coding() {
	        System.out.println("Java太卷了T_T，快去学Go吧！");
	    }
	}
	
	class PHPCoder extends Coder{
	    @Override
	    public void coding() {
	        System.out.println("PHP是世界上最好的语言");
	    }
	}
	
	class C艹Coder extends Coder{
	    @Override
	    public void coding() {
	        System.out.println("笑死，Java再牛逼底层不还得找我？");
	    }
	}
	}


### 3、里氏替换原则

​	所有引用基类的地方必须能透明地使用其子类的对象。

子类可以扩展父类的功能，但不能改变父类原有的功能：

1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
2. 子类可以增加自己特有的方法。
3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。
4. 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或与父类一样。

		public abstract class Coder {
   	public void coding() {
   	 	System.out.println("我会打代码");
   	}
		class JavaCoder extends Coder{
   		 	/**
   	  	* 子类除了会打代码之外，还会打游戏
   	        	*/
   	 	public void game(){
   	     	System.out.println("艾欧尼亚最强王者已上号");
   	 	}
   	}
   	}



### 4、依赖倒转原则

依赖倒转原则（Dependence Inversion Principle）也是我们一直在使用的，最明显的就是我们的Spring框架了。

> 高层模块不应依赖于底层模块，它们都应该依赖抽象。抽象不应依赖于细节，细节应该依赖于抽象。



### 5、接口隔离原则

接口隔离原则（Interface Segregation Principle, ISP）实际上是对接口的细化。

> 客户端不应依赖那些它不需要的接口。



### 6、合成复用原则

合成复用原则（Composite Reuse Principle）的核心就是委派。

> 优先使用对象组合，而不是通过继承来达到复用的目的。



### 7、迪米特法则

迪米特法则（Law of Demeter）又称最少知识原则，是对程序内部数据交互的限制。

> 每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。



	public class Main {
	public static void main(String[] args) throws IOException {
	    Socket socket = new Socket("localhost", 8080);   //假设我们当前的程序需要进行网络通信
	    Test test = new Test();
	    test.test(socket);   //现在需要执行test方法来做一些事情
	}
	
	static class Test {
	    /**
	     * 比如test方法需要得到我们当前Socket连接的本地地址
	     */
	    public void test(Socket socket){
	        System.out.println("IP地址："+socket.getLocalAddress());
	    }
	}}


	public class Main {
	public static void main(String[] args) throws IOException {
	    Socket socket = new Socket("localhost", 8080);
	    Test test = new Test();
	    test.test(socket.getLocalAddress().getHostAddress());  //在外面解析好就行了
	}
	
	static class Test {
	    public void test(String str){   //一个字符串就能搞定，就没必要丢整个对象进来
	        System.out.println("IP地址："+str);
	    }
	}}










# 创建型

### 1、工厂方法模式

如果所有的对象我们都通过new的方式去创建，那么当我们的程序中大量使用此对象时，突然有一天这个对象的构造方法或是类名发生了修改，那我们岂不是得挨个去进行修改？根据迪米特法则，我们应该尽可能地少与其他类进行交互，所以我们可以将那些需要频繁出现的对象创建，封装到一个工厂类中，当我们需要对象时，直接调用工厂类中的工厂方法来为我们生成对象，这样，就算类出现了变动，我们也只需要修改工厂中的代码即可，而不是大面积地进行修改。



**当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。**

 工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。

例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。

 **如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。**

 继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？

解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。

让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 `圆形按钮`Round­Button子类来继承标准的 `按钮`Button类。 但是， 你需要告诉 `UI框架`UIFramework类使用新的子类按钮代替默认按钮。

为了实现这个功能， 你可以根据基础框架类开发子类 `圆形按钮 UI`UIWith­Round­Buttons ， 并且重写其 `create­Button`创建按钮方法。 基类中的该方法返回 `按钮`对象， 而你开发的子类返回 `圆形按钮`对象。 现在， 你就可以使用 `圆形按钮 UI`类代替 `UI框架`类。 就是这么简单！

 **如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。**

 在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。

让我们思考复用现有对象的方法：

1. 首先， 你需要创建存储空间来存放所有已经创建的对象。
2. 当他人请求一个对象时， 程序将在对象池中搜索可用对象。
3. … 然后将其返回给客户端代码。
4. 如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。

这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。

可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是**新对象**， 其无法返回现有实例。

因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。

##  实现方式

1. 让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。

2. 在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。

3. 在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。

   你可能需要在工厂方法中添加临时参数来控制返回的产品类型。

   工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 `switch`分支运算符， 用于选择各种需要实例化的产品类。 但是不要担心， 我们很快就会修复这个问题。

4. 现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。

5. 如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。

   例如， 设想你有以下一些层次结构的类。 基类 `邮件`及其子类 `航空邮件`和 `陆路邮件` ；  `运输`及其子类 `飞机`, `卡车`和 `火车` 。  `航空邮件`仅使用 `飞机`对象， 而 `陆路邮件`则会同时使用 `卡车`和 `火车`对象。 你可以编写一个新的子类 （例如 `火车邮件` ） 来处理这两种情况， 但是还有其他可选的方案。 客户端代码可以给 `陆路邮件`类传递一个参数， 用于控制其希望获得的产品。

6. 如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为。

##  工厂方法模式优缺点

-  你可以避免创建者和具体产品之间的紧密耦合。
-  *单一职责原则*。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。
-  *开闭原则*。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。

-  **缺点**：应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。





## 建造者模式

建造者模式也是非常常见的一种设计模式，我们经常看到有很多的框架都为我们提供了形如`XXXBuilder`的类型，我们一般也是使用这些类来创建我们需要的对象。



	public class Student {
		...
	
	//一律使用建造者来创建，不对外直接开放
	private Student(int id, int age, int grade, String name, String college, String profession, List<String> awards) {
	    ...
	}
	
	public static StudentBuilder builder(){   //通过builder方法直接获取建造者
	    return new StudentBuilder();
	}
	
	public static class StudentBuilder{   //这里就直接创建一个内部类
	    //Builder也需要将所有的参数都进行暂时保存，所以Student怎么定义的这里就怎么定义
	    int id;
	    int age;
	    int grade;
	    String name;
	    String college;
	    String profession;
	    List<String> awards;
	
	    public StudentBuilder id(int id){    //直接调用建造者对应的方法，为对应的属性赋值
	        this.id = id;
	        return this;   //为了支持链式调用，这里直接返回建造者本身，下同
	    }
	
	    public StudentBuilder age(int age){
	        this.age = age;
	        return this;
	    }
	  
	  	...
	
	    public StudentBuilder awards(String... awards){
	        this.awards = Arrays.asList(awards);
	        return this;
	    }
	    
	    public Student build(){    //最后我们只需要调用建造者提供的build方法即可根据我们的配置返回一个对象
	        return new Student(id, age, grade, name, college, profession, awards);
	    }
	}
	}
	
	//现在，我们就可以使用建造者来为我们生成对象了
	
	public static void main(String[] args) {
	    Student student = Student.builder()   //获取建造者
	            .id(1)    //逐步配置各个参数
	            .age(18)
	            .grade(3)
	            .name("小明")
	            .awards("ICPC-ACM 区域赛 金牌", "LPL 2022春季赛 冠军")
	            .build();   //最后直接建造我们想要的对象
	}








## 单例模式

单例那么肯定就是只有一个实例对象，在我们的整个程序中，同一个类始终只会有一个对象来进行操作。比如数据库连接类，实际上我们只需要创建一个对象或是直接使用静态方法就可以了，没必要去创建多个对象。

**如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。**

 单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。

 **如果你需要更加严格地控制全局变量， 可以使用单例模式。**

 单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。

请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 `获取实例`方法， 即 getInstance 中的代码即可实现。

#### 饿汉单例

	public class Singleton {
	private final static Singleton INSTANCE = new Singleton();   //用于引用全局唯一的单例对象，在一开始就创建好
	
	private Singleton() {}   //不允许随便new，需要对象直接找getInstance
	
	public static Singleton getInstance(){   //获取全局唯一的单例对象
	    return INSTANCE;
	}
	}
	//这样，当我们需要获取此对象时，只能通过getInstance()来获取唯一的对象：
	public static void main(String[] args) {
	    Singleton singleton = Singleton.getInstance();
	}
#### 懒汉式单例
	public class Singleton {
	private static Singleton INSTANCE;   //在一开始先不进行对象创建
	
	private Singleton() {}   //不用多说了吧
	
	public static Singleton getInstance(){   //将对象的创建延后到需要时再进行
	    if(INSTANCE == null) {    //如果实例为空，那么就进行创建，不为空说明已经创建过了，那么就直接返回
	        INSTANCE = new Singleton();
	    }
	    return INSTANCE;
	}
	}
你不去用它，它是不会给你提前准备单例对象的（**延迟加载**，懒加载），当我们需要获取对象时，才会进行检查并创建。

由于懒汉式是在方法中进行的初始化，在多线程环境下，可能会出现问题

![image-20230301111737649](https://oss.itbaima.cn/internal/markdown/2023/03/01/w1oN7u3SxG4cEzL.png)

在多线程环境下，如果三条线程同时调用`getInstance()`方法，会同时进行`INSTANCE == null`的判断，那么此时由于确实还没有进行任何实例化，所以导致三条线程全部判断为`true`（而饿汉式由于在类加载时就创建完成，不会存在这样的问题）此时问题就来了，我们既然要使用单例模式，那么肯定是只希望对象只被初始化一次的，但是现在由于多线程的机制，导致对象被多次创建。



针对于懒汉式单例，我们还得进行一些改进：

	public static synchronized Singleton getInstance(){   //方法必须添加synchronized关键字加锁
	if(INSTANCE == null) {
	    INSTANCE = new Singleton();
	}
	return INSTANCE;
	}


​	
​	既然多个线程要调用，那么我们就直接加一把锁，在方法上添加synchronized关键字即可，这样同一时间只能有一个线程进入了。虽然这样简单粗暴，但是在高并发的情况下，效率肯定是比较低的，我们来看看如何进行优化：

	public static Singleton getInstance(){
	    if(INSTANCE == null) {
	        synchronized (Singleton.class) {    //实际上只需要对赋值这一步进行加锁即可
	            INSTANCE = new Singleton();   
	        }
	    }
	    return INSTANCE;
	}



不过这样还不完美，因为这样还是有可能多个线程同时判断为null而进入等锁的状态，所以，我们还得加一层内层判断：


	public static Singleton getInstance(){
		if(INSTANCE == null) {
	        synchronized (Singleton.class) {
	            if(INSTANCE == null) INSTANCE = new Singleton();  //内层还要进行一次检查，双重检查锁定
	        }
	    }
	    return INSTANCE;
	}

不过我们还少考虑了一样内容，其实IDEA此时应该是给了黄标了：



![image-20230301111754155](https://oss.itbaima.cn/internal/markdown/2023/03/01/I9PAi6HRbyMNsJn.png)



可以看到，这种情况下，IDEA会要求我们添加一个`volatile`给`INSTANCE`，各位还记得这个关键字有什么作用吗？没错，我们还需要保证`INSTANCE`在线程之间的可见性，这样当其他线程进入之后才会拿`INSTANCE`由其他线程更新的最新值去判断，这样，就差不多完美了。

那么，有没有一种更好的，不用加锁的方式也能实现延迟加载的写法呢？我们可以使用静态内部类：



	public class Singleton {
	private Singleton() {}
	
	private static class Holder {   //由静态内部类持有单例对象，但是根据类加载特性，我们仅使用Singleton类时，不会对静态内部类进行初始化
	    private final static Singleton INSTANCE = new Singleton();
	}
	
	public static Singleton getInstance(){   //只有真正使用内部类时，才会进行类初始化
	    return Holder.INSTANCE;   //直接获取内部类中的
	}
	}
这种方式显然是最完美的懒汉式解决方案，没有进行任何的加锁操作，也能保证线程安全，不过要实现这种写法，跟语言本身也有一定的关联，并不是所有的语言都支持这种写法。



