# 如果选择随机而不是一致性哈希

服务实例的性能差异不大，且请求负载较为均衡
需要简单、高效且容易实现的负载均衡策略,
服务实例频繁变化时，随机策略能够更容易适应
对于无状态的服务，随机负载均衡不需要依赖请求的内容，而一致性哈希则主要用于有状态的场景。
Dubbo 的默认策略是随机法





**负载均衡** 指的是将用户请求分摊到不同的服务器上处理，以提高系统整体的并发处理能力以及可靠性。



![多服务实例-负载均衡](https://oss.javaguide.cn/github/javaguide/high-performance/load-balancing/multi-service-load-balancing.drawio.png)



负载均衡可以简单分为 **服务端负载均衡** 和 **客户端负载均衡** 这两种。

**四层负载均衡** 工作在 OSI 模型第四层，也就是传输层，这一层的主要协议是 TCP/UDP，负载均衡器在这一层能够看到数据包里的源端口地址以及目的端口地址，会基于这些信息通过一定的负载均衡算法将数据包转发到后端真实服务器。也就是说，四层负载均衡的核心就是 IP+端口层面的负载均衡，不涉及具体的报文内容。

**七层负载均衡** 工作在 OSI 模型第七层，也就是应用层，这一层的主要协议是 HTTP 。这一层的负载均衡比四层负载均衡路由网络请求的方式更加复杂，它会读取报文的数据部分（比如说我们的 HTTP 部分的报文），然后根据读取到的数据内容（如 URL、Cookie）做出负载均衡决策。也就是说，七层负载均衡器的核心是报文内容（如 URL、Cookie）层面的负载均衡，执行第七层负载均衡的设备通常被称为 **反向代理服务器** 。





### [随机法](#随机法)

**随机法** 是最简单粗暴的负载均衡算法。

如果没有配置权重的话，所有的服务器被访问到的概率都是相同的。如果配置权重的话，权重越高的服务器被访问的概率就越大。

未加权重的随机算法适合于服务器性能相近的集群，其中每个服务器承载相同的负载。加权随机算法适合于服务器性能不等的集群，权重的存在可以使请求分配更加合理化。

不过，随机算法有一个比较明显的缺陷：部分机器在一段时间之内无法被随机到，毕竟是概率算法，就算是大家权重一样， 也可能会出现这种情况。

于是，**轮询法** 来了！

### [轮询法](#轮询法)

轮询法是挨个轮询服务器处理，也可以设置权重。

如果没有配置权重的话，每个请求按时间顺序逐一分配到不同的服务器处理。如果配置权重的话，权重越高的服务器被访问的次数就越多。

未加权重的轮询算法适合于服务器性能相近的集群，其中每个服务器承载相同的负载。加权轮询算法适合于服务器性能不等的集群，权重的存在可以使请求分配更加合理化。

在加权轮询的基础上，还有进一步改进得到的负载均衡算法，比如平滑的加权轮训算法。

### [一致性 Hash 法](#一致性-hash-法)

和哈希法类似，一致性 Hash 法也可以让相同参数的请求总是发到同一台服务器处理。不过，它解决了哈希法存在的一些问题。

常规哈希法在服务器数量变化时，哈希值会重新落在不同的服务器上，这明显违背了使用哈希法的本意。而一致性哈希法的核心思想是将数据和节点都映射到一个哈希环上，然后根据哈希值的顺序来确定数据属于哪个节点。当服务器增加或删除时，只影响该服务器的哈希，而不会导致整个服务集群的哈希键值重新分布。

### [最小连接法](#最小连接法)

当有新的请求出现时，遍历服务器节点列表并选取其中连接数最小的一台服务器来响应当前请求。相同连接的情况下，可以进行加权随机。

最少连接数基于一个服务器连接数越多，负载就越高这一理想假设。然而， 实际情况是连接数并不能代表服务器的实际负载，有些连接耗费系统资源更多，有些连接不怎么耗费系统资源。

### [最少活跃法](#最少活跃法)

最少活跃法和最小连接法类似，但要更科学一些。最少活跃法以活动连接数为标准，活动连接数可以理解为当前正在处理的请求数。活跃数越低，说明处理能力越强，这样就可以使处理能力强的服务器处理更多请求。相同活跃数的情况下，可以进行加权随机。







# 1.添加虚拟节点的目的是什么?

在一致性哈希(Consistent Hashing)中，虚拟节点的引入是为了 提高负载均衡的均匀性，尤其是在节点(服务器)变动时，尽量减少请求的重新分配和数据的不均匀分布。

## 避免负载不均衡:

在没有虚拟节点的情况下，每个物理节点(真实节点)都会映射到哈希环上的一个单独的点。假设哈希值是均匀分布的，那么节点数量少时，可能有一些节点的哈希值落在哈希环的“稀疏”区域，导致某些节点需要处理大量请求，而其他节点的负载非常轻。这样就会造成负载不均衡。
引入虚拟节点后，每个物理节点会映射到多个虚拟节点，从而增加哈希环上的点数，使负载分布更加均匀。每个虚拟节点都有自己的哈希值，物理节点通过这些虚拟节点在环上“分布”负载更均匀。

## 提高节点的扩展性和容错性:

在分布式系统中，节点可能会增加或减少。没有虚拟节点时，节点的增加或删除会导致哈希环上的重新分配，可能导致大量的请求重定向到其他节点。引入虚拟节点后，节点的增加或删除只会影响与该节点相关的少部分虚拟节点，从而减少了请求的迁移。
举个例子，假设你有 3个物理节点，并且它们都只有一个虚拟节点(哈希环上的一个点)，如果增加一个节点，这个新增节点可能会影响到哈希环上大部分区域的重新分配，导致很多请求需要迁移到新的节点。而如果每个物理节点有多个虚拟节点，新增一个节点只会影响哈希环上少量的区域，从而减少了请求的迁移量

## 减少单节点故障的影响

如果一个物理节点故障且没有虚拟节点，那么所有映射到该节点的请求都会丢失。引入虚拟节点后，某个物理节点故障时，其对应的虚拟节点也会失效，但其他虚拟节点可能会分摊其负载，减少系统的影响。





# private SortedMap<Integer, String> shards = newTreeMap<>();为什么用 treeMap?

**自动排序**: TreeMap 会根据键的顺序自动进行排序，因此当我们使用TreeMap存储哈希值与虚拟节点之间的映射时，哈希值将会始终保持有序。这一点非常重要因为一致性哈希算法依赖于将虚拟节点映射到哈希环上的不同位置，并且需要按哈希值的大小顺序来查找最近的节点。
具体到一致性哈希算法，哈希环上各个节点的哈希值必须是 有序的，而 TreeMap 正是通过底层的红黑树实现了这种有序性，确保了虚拟节点在哈希环上的顺序正确。
**高效的范围查找**: TreeMap 提供了非常高效的范围查找操作。它允许我们使用tai1Map()方法查找从某个特定键开始的所有键值对，这对于一致性哈希中的 查询下
一个节点 操作至关重要，
例如，当我们根据某个数据的哈希值(如请求的哈希值)来查找该数据应该映射到哪个虚拟节点时，如果我们在shards 中使用 TreeMap，可以通过 tailMap()方法找到所有大于等于该哈希值的虚拟节点，并且快速获取到最近的一个虚拟节点。
