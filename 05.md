# 1. 消费方缓存

> 如果nacos注册中心挂掉会怎么样？按现在的程序，是没法继续运行的，为了让我们得程序更加健壮，我们可以将获取到的服务调用方实例进行缓存

~~~java
package com.mszlu.rpc.netty;

import com.alibaba.nacos.api.naming.pojo.Instance;
import com.mszlu.rpc.config.MsRpcConfig;
import com.mszlu.rpc.constants.CompressTypeEnum;
import com.mszlu.rpc.constants.MessageTypeEnum;
import com.mszlu.rpc.constants.SerializationTypeEnum;
import com.mszlu.rpc.exception.MsRpcException;
import com.mszlu.rpc.factory.SingletonFactory;
import com.mszlu.rpc.message.MsMessage;
import com.mszlu.rpc.message.MsRequest;
import com.mszlu.rpc.message.MsResponse;
import com.mszlu.rpc.netty.codec.MsRpcDecoder;
import com.mszlu.rpc.netty.codec.MsRpcEncoder;
import com.mszlu.rpc.netty.handler.client.MsNettyClientHandler;
import com.mszlu.rpc.netty.handler.client.UnprocessedRequests;
import com.mszlu.rpc.register.nacos.NacosTemplate;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.logging.LoggingHandler;
import lombok.extern.slf4j.Slf4j;

import java.net.InetSocketAddress;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CopyOnWriteArraySet;

@Slf4j
public class NettyClient implements MsClient {
    private final Bootstrap bootstrap;
    private final EventLoopGroup eventLoopGroup;
    private  UnprocessedRequests unprocessedRequests;
    private NacosTemplate nacosTemplate;
    private MsRpcConfig msRpcConfig;
    //读快 写慢 不适用于存取大量数据  并且写多的场景
    private static final Set<String> SERVICES= new CopyOnWriteArraySet<>();


    public NettyClient(){
        this.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);
        this.nacosTemplate = SingletonFactory.getInstance(NacosTemplate.class);

        eventLoopGroup = new NioEventLoopGroup();
        bootstrap = new Bootstrap();
        bootstrap.group(eventLoopGroup)
                .channel(NioSocketChannel.class)
                .handler(new LoggingHandler(LogLevel.INFO))
                //超时时间设置
                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS,5000)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) throws Exception {
                        ch.pipeline ().addLast ( "decoder",new MsRpcDecoder() );
                        ch.pipeline ().addLast ( "encoder",new MsRpcEncoder());
                        ch.pipeline ().addLast ( "handler",new MsNettyClientHandler() );

                    }
                });
    }

    public Object sendRequest(MsRequest msRequest,String host,int port) {
        //发送数据
        //1. 连接netty服务，获取channel
//        InetSocketAddress inetSocketAddress = new InetSocketAddress(host, port);
        //通过注册中心获取主机和端口
        String serviceName = msRequest.getInterfaceName() + msRequest.getVersion();

        InetSocketAddress inetSocketAddress = null;
        if (!SERVICES.isEmpty()){
            //有缓存的服务提供者服务器，直接获取
            //随机获取一个
            Optional<String> optional = SERVICES.stream().skip(SERVICES.size() - 1).findFirst();
            if (optional.isPresent()){
                String ipAndPort = optional.get();
                String[] split = ipAndPort.split(",");
                inetSocketAddress = new InetSocketAddress(split[0],Integer.parseInt(split[1]));
                log.info("走了缓存的服务提供者地址，省去了连接nacos的过程...");
            }
        }
        if (inetSocketAddress == null){
            Instance oneHealthyInstance = null;
            try {
                //根据组 进行获取健康实例，服务提供方和消费方 不在一个组内 无法获取实例
                oneHealthyInstance = nacosTemplate.getOneHealthyInstance(serviceName,msRpcConfig.getNacosGroup());
            } catch (Exception e) {
                throw new MsRpcException("没有获取到可用的服务提供者");
            }
            //从nacos获取实例后，将其缓存起来
            SERVICES.add(oneHealthyInstance.getIp()+","+oneHealthyInstance.getPort());
            //
            inetSocketAddress = new InetSocketAddress(oneHealthyInstance.getIp(), oneHealthyInstance.getPort());
        }

        //连接
        CompletableFuture<Channel> completableFuture = new CompletableFuture<>();

        bootstrap.connect(inetSocketAddress).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (future.isSuccess()){
                    //代表连接成功，将channel放入任务中
                    completableFuture.complete(future.channel());
                }else {
                    throw new MsRpcException("连接服务器失败");
                }
            }
        });
        //结果获取的任务
        CompletableFuture<MsResponse<Object>> resultFuture = new CompletableFuture<>();
        try {
            Channel channel = completableFuture.get();

            if (channel.isActive()){
                //将任务 存起来，和请求id对应，便于后续读取到数据后，可以根据请求id，将任务标识完成
                unprocessedRequests.put(msRequest.getRequestId(),resultFuture);
                //构建发送的数据
                MsMessage msMessage = MsMessage.builder()
                        .messageType(MessageTypeEnum.REQUEST.getCode())
                        .codec(SerializationTypeEnum.PROTOSTUFF.getCode())
                        .compress(CompressTypeEnum.GZIP.getCode())
                        .data(msRequest)
                        .build();
                //请求,并添加监听
                channel.writeAndFlush(msMessage).addListener(new ChannelFutureListener() {
                    @Override
                    public void operationComplete(ChannelFuture future) throws Exception {
                        if (future.isSuccess()){
                            //任务完成
                            log.info("发送数据成功:{}",msMessage);
                        }else{
                            //发送数据失败
                            future.channel().close();
                            //任务标识为完成 有异常
                            resultFuture.completeExceptionally(future.cause());
                            log.info("发送数据失败:",future.cause());
                        }
                    }
                });

            }

        } catch (Exception e) {
            throw new MsRpcException("获取Channel失败",e);
        }

        return resultFuture;
    }

    public MsRpcConfig getMsRpcConfig() {
        return msRpcConfig;
    }

    public void setMsRpcConfig(MsRpcConfig msRpcConfig) {
        this.msRpcConfig = msRpcConfig;
    }
}

~~~

# 2. 心跳

> 消费方缓存后，我们发现一个问题，万一缓存的服务挂掉了怎么办？

**有两个解决方案：**

1. 连接失败，记录，从缓存中剔除
2. 心跳检测，发现不在线的服务及时剔除



## 2.1 连接失败 删除

NettyClient:

~~~java
//连接
        CompletableFuture<Channel> completableFuture = new CompletableFuture<>();

        String finalIpAndPort = ipAndPort;
        bootstrap.connect(inetSocketAddress).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (future.isSuccess()){
                    //代表连接成功，将channel放入任务中
                    completableFuture.complete(future.channel());
                }else {
                    //连接失败 从 缓存中 去除
                    if (finalIpAndPort != null){
                        SERVICES.remove(finalIpAndPort);
                        log.info("删除provider服务缓存成功...");
                    }
                    //标识 任务失败
                    completableFuture.completeExceptionally(future.cause());
                    throw new MsRpcException("连接服务器失败");
                }
            }
        });
~~~

## 2.2 发送心跳包

在常量中定义，心跳包的消息类型，以及返回值

~~~java
package com.mszlu.rpc.constants;

public class MsRpcConstants {

    public static final int TOTAL_LENGTH = 16;

    public static final byte[] MAGIC_NUMBER = {(byte)'m',(byte)'s',(byte)'n',(byte)'b'};

    public static final int VERSION = 1;

    //协议的头 长度为16
    public static final int HEAD_LENGTH = 16;

    //ping
    public static final byte HEARTBEAT_REQUEST_TYPE = 3;
    //pong
    public static final byte HEARTBEAT_RESPONSE_TYPE = 4;
    
    public static final String PING = "ping";
    public static final String PONG = "pong";


}

~~~

> ping pong 就是心跳包，就是打乒乓球，有来有回，一旦一方不回应了，就认为掉线了



### 2.2.1 KeepAlive

长连接的应用场景非常的广泛，比如监控系统，IM系统，即时报价系统，推送服务等等。像这些场景都是比较注重实时性，如果每次发送数据都要进行一次DNS解析，建立连接的过程肯定是极其影响体验。

而长连接的维护必然需要一套机制来控制。比如 HTTP/1.0 通过在 header 头中添加 `Connection:Keep-Alive`参数，如果当前请求需要保活则添加该参数作为标识，否则服务端就不会保持该连接的状态，发送完数据之后就关闭连接。

HTTP/1.1以后 Keep-Alive 是默认打开的。

Netty 是 基于 TCP 协议开发的，在四层协议 TCP 协议的实现中也提供了` keepalive 报文`用来探测对端是否可用。TCP 层将在`定时时间到后发送相应的 KeepAlive 探针以确定连接可用性`。

`tcp-keepalive`，操作系统内核支持，但是不默认开启,应用需要自行开启，开启之后有三个参数会生效，来决定一个 keepalive 的行为。

~~~shell
net.ipv4.tcp_keepalive_time = 7200
net.ipv4.tcp_keepalive_probes = 9
net.ipv4.tcp_keepalive_intvl = 75
~~~

`tcp_keepalive_time`： 在 TCP 保活打开的情况下，最后一次数据交换到 TCP 发送第一个保活探测包的间隔，即允许的持续空闲时长，或者说每次正常发送心跳的周期，默认值为7200s（2h）；

`tcp_keepalive_probes`： 在 tcp_keepalive_time 之后，没有接收到对方确认，继续发送保活探测包次数，默认值为9（次）；

`tcp_keepalive_intvl`：在 tcp_keepalive_time 之后，没有接收到对方确认，继续发送保活探测包的发送频率，默认值为75s。

`TCP KeepAlive` 是用于检测连接的死活，而心跳机制则附带一个额外的功能：`检测通讯双方的存活状态`。两者听起来似乎是一个意思，但实际上却大相径庭。

考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的`连接活着但业务提供方已死的状态`，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态一直向当前服务器发送些必然会失败的请求。

可以通过如下命令查看系统tcp-keepalive参数配置：

~~~shell
sysctl -a | grep keepalive

cat /proc/sys/net/ipv4/tcp_keepalive_time

sysctl net.ipv4.tcp_keepalive_time
~~~

**Netty 中也提供了设置 tcp-keepalive 的设置:**

~~~java
try {
            ServerBootstrap b = new ServerBootstrap();

            eventExecutors = new DefaultEventExecutorGroup(RuntimeUtil.cpus() * 2,new MsRpcThreadFactory(msServiceProvider));
            b.group(workerGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    // TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。
                    .childOption(ChannelOption.TCP_NODELAY,true)
                    //是否开启 TCP 底层心跳机制
                    .childOption(ChannelOption.SO_KEEPALIVE,true)
                    //表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数
                    .childOption(ChannelOption.SO_BACKLOG,1024)
                    .handler(new LoggingHandler(LogLevel.INFO))
                    // 当客户端第一次进行请求的时候才会进行初始化
                    .childHandler(new NettyServerInitiator(eventExecutors));

            // 绑定端口，同步等待绑定成功
             b.bind(msServiceProvider.getMsRpcConfig().getProviderPort()).sync().channel();
            isRunning = true;
             Runtime.getRuntime().addShutdownHook(new Thread(){
                 @Override
                 public void run() {
                    stopNettyServer();
                 }
             });
        }catch (InterruptedException e){
            log.error("occur exception when start server:",e);
        }
~~~

> 一个 Netty 服务端可能会面临上万个连接，如何去维护这些连接是应用应该去处理的事情。在 Netty 中提供了 `IdleStateHandler` 类专门用于处理心跳。



`IdleStateHandler` 的构造函数如下：

~~~java
public IdleStateHandler(long readerIdleTime, long writerIdleTime, 
                        long allIdleTime,TimeUnit unit){
  
}
~~~

`第一个参数 readerIdleTime`是隔多久检查一下读事件是否发生，如果 channelRead() 方法超过 readerIdleTime 时间未被调用则会触发超时事件调用 userEventTrigger() 方法；

`第二个参数 writerIdleTime`是隔多久检查一下写事件是否发生，writerIdleTime 写空闲超时时间设定，如果 write() 方法超过 writerIdleTime 时间未被调用则会触发超时事件调用 userEventTrigger() 方法；

`第三个参数 allIdleTime`是全能型参数，隔多久检查读写事件；

`第四个参数 unit`表示当前的时间单位。

所以这里可以分别控制读，写，读写超时的时间，单位为秒，如果是0表示不检测，所以如果全是0，则相当于没添加这个 IdleStateHandler，连接是个普通的短连接。


### 2.2.2 Netty实现服务端心跳检测

1. 在NettyServerInitiator中 添加`IdleStateHandler` 

   ~~~java
   package com.mszlu.rpc.netty.handler.server;
   
   import com.mszlu.rpc.netty.codec.MsRpcDecoder;
   import com.mszlu.rpc.netty.codec.MsRpcEncoder;
   import io.netty.channel.ChannelInitializer;
   import io.netty.channel.socket.SocketChannel;
   import io.netty.handler.timeout.IdleStateHandler;
   import io.netty.util.concurrent.EventExecutorGroup;
   
   import java.util.concurrent.TimeUnit;
   
   public class NettyServerInitiator extends ChannelInitializer<SocketChannel> {
   
       private EventExecutorGroup eventExecutors;
   
       public NettyServerInitiator(EventExecutorGroup eventExecutors) {
           this.eventExecutors = eventExecutors;
       }
   
       protected void initChannel(SocketChannel ch) throws Exception {
           //处理心跳，10秒钟 未收到 读请求 关闭客户端连接
           ch.pipeline().addLast(new IdleStateHandler(10, 0, 0, TimeUnit.SECONDS));
           
           ch.pipeline ().addLast ( "decoder",new MsRpcDecoder() );
           ch.pipeline ().addLast ( "encoder",new MsRpcEncoder());
           ch.pipeline ().addLast ( eventExecutors,"handler",new MsNettyServerHandler() );
       }
   }
   
   ~~~

2. MsNettyServerHandler 中 实现userEventTriggered方法

   ~~~java
   /**
        * 如果10s没有读请求，不进行 处理，以免连接过多，每个都回复 会造成网络压力
        * @param ctx
        * @param evt
        * @throws Exception
        */
       @Override
       public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
           if (evt instanceof IdleStateEvent) {
               IdleState state = ((IdleStateEvent) evt).state();
               if (state == IdleState.READER_IDLE) {
                   log.info("客户端10s 未发送读请求，判定失效，进行关闭");
                   ctx.close();
               }
           } else {
               super.userEventTriggered(ctx, evt);
           }
       }
   
       @Override
       public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
           super.exceptionCaught(ctx, cause);
           //出现异常 关闭连接
           ctx.close();
       }
   ~~~

   

### 2.2.3 Netty客户端实现心跳检测

> 客户端应该每隔一段时间发起心跳检测，比如3s发送一次，检测服务端是否健康，如果服务端关闭会触发`channelInactive`方法，代表服务端下线。Netty 中的 `channelInactive()` 方法是通过 Socket 连接关闭时挥手数据包触发的
>
> 服务端下线，我们要及时将缓存中的服务去除掉

1. NettyClient

   ~~~java
   public NettyClient(){
           this.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);
           this.nacosTemplate = SingletonFactory.getInstance(NacosTemplate.class);
   
           eventLoopGroup = new NioEventLoopGroup();
           bootstrap = new Bootstrap();
           bootstrap.group(eventLoopGroup)
                   .channel(NioSocketChannel.class)
                   .handler(new LoggingHandler(LogLevel.INFO))
                   //超时时间设置
                   .option(ChannelOption.CONNECT_TIMEOUT_MILLIS,5000)
                   .handler(new ChannelInitializer<SocketChannel>() {
                       @Override
                       protected void initChannel(SocketChannel ch) throws Exception {
                           //3s 没收到写请求，进行心跳检测
                           ch.pipeline().addLast(new IdleStateHandler(0, 3, 0, TimeUnit.SECONDS));
                           ch.pipeline ().addLast ( "decoder",new MsRpcDecoder() );
                           ch.pipeline ().addLast ( "encoder",new MsRpcEncoder());
                           ch.pipeline ().addLast ( "handler",new MsNettyClientHandler() );
   
                       }
                   });
       }
   ~~~

2. MsNettyClientHandler

   ~~~java
   @Override
       public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
           if (evt instanceof IdleStateEvent) {
               IdleState state = ((IdleStateEvent) evt).state();
               if (state == IdleState.WRITER_IDLE) {
                   log.info("3s未收到写请求，发起心跳,地址：{}", ctx.channel().remoteAddress());
                   MsMessage rpcMessage = new MsMessage();
                   rpcMessage.setCodec(SerializationTypeEnum.PROTOSTUFF.getCode());
                   rpcMessage.setCompress(CompressTypeEnum.GZIP.getCode());
                   rpcMessage.setMessageType(MsRpcConstants.HEARTBEAT_REQUEST_TYPE);
                   rpcMessage.setData(MsRpcConstants.PING);
                   ctx.writeAndFlush(rpcMessage).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
               }
           } else {
               super.userEventTriggered(ctx, evt);
           }
       }
   
       @Override
       public void channelActive(ChannelHandlerContext ctx) throws Exception {
           //代表通道已连接
           //表示channel活着
           ctx.fireChannelActive();
       }
   
       @Override
       public void channelInactive(ChannelHandlerContext ctx) throws Exception {
           //代表连接关闭了
           log.info("服务端连接关闭:{}",ctx.channel().remoteAddress());
           //需要将缓存清除掉
           
           //标识channel不活着
           ctx.fireChannelInactive();
       }
   ~~~

   

3. 接收心跳包，返回PONG, MsNettyServerHandler

   ~~~java
   @Override
       public void channelRead(ChannelHandlerContext ctx, Object msg) {
           try {
               //这里 接收到 请求的信息，然后根据请求，找到对应的服务提供者，调用，获取结果，然后返回
               //消费方 会启动一个 客户端，用户接收返回的数据
               if (msg instanceof MsMessage){
                   MsMessage msMessage = (MsMessage) msg;
                   byte messageType = msMessage.getMessageType();
                   if (messageType == MessageTypeEnum.HEARTBEAT_PING.getCode()){
                       //心跳包 返回PONG
                       msMessage.setMessageType(MessageTypeEnum.HEARTBEAT_PONG.getCode());
                       msMessage.setData(MsRpcConstants.PONG);
                   }else {
                       if (msMessage.getData() instanceof MsRequest) {
                           //客户端请求
                           MsRequest msRequest = (MsRequest) msMessage.getData();
                           Object handler = requestHandler.handler(msRequest);
                           msMessage.setMessageType(MessageTypeEnum.RESPONSE.getCode());
                           if (ctx.channel().isActive() && ctx.channel().isWritable()) {
                               MsResponse<Object> msResponse = MsResponse.success(handler, msRequest.getRequestId());
                               msMessage.setData(msResponse);
                           } else {
                               MsResponse<Object> msResponse = MsResponse.fail("net fail");
                               msMessage.setData(msResponse);
                           }
                           log.info("服务端收到数据，并处理完成{}:", msMessage);
                       }
                   }
                   //写完数据 并关闭通道
                   ctx.writeAndFlush(msMessage).addListener(ChannelFutureListener.CLOSE);
               }
           }catch (Exception e){
               throw new MsRpcException("数据读取异常",e);
           }finally {
               //释放 以防内存泄露
               ReferenceCountUtil.release(msg);
           }
       }
   ~~~



# 3. 重试

> 处理完心跳连接，我们需要清除缓存，但是心跳检测出问题，有可能是网络的原因，我们不能立马将其从缓存中删除，可以先进行重连，如果重连达到一定次数不成功，在进行处理



## 3.1 定义ChannelHandlerHolder

~~~java
package com.mszlu.rpc.netty.handler.idle;  
  
import io.netty.channel.ChannelHandler;  
  
/** 
 *  
 * 客户端的ChannelHandler集合，由子类实现，这样做的好处： 
 * 继承这个接口的所有子类可以很方便地获取ChannelPipeline中的Handlers 
 * 获取到handlers之后方便ChannelPipeline中的handler的初始化和在重连的时候也能很方便 
 * 地获取所有的handlers 
 */  
public interface ChannelHandlerHolder {  
  
    ChannelHandler[] handlers();  
}  
~~~

## 3.2 链路检测狗

> 重连检测狗，当发现当前的链路不稳定关闭之后，进行12次重连

1. 首先 服务端 写数据后，不能关闭通道

   ~~~java
   //写完数据 不能关闭通道
                 ctx.writeAndFlush(msMessage).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
   ~~~

2. 链路检测狗

   ~~~java
   package com.mszlu.rpc.netty.handler.idle;
    
   /**
    *
    * 重连检测狗，当发现当前的链路不稳定关闭之后，进行12次重连
    */
   import com.mszlu.rpc.exception.MsRpcException;
   import io.netty.bootstrap.Bootstrap;
   import io.netty.channel.*;
   import io.netty.channel.ChannelHandler.Sharable;
   import io.netty.util.Timeout;
   import io.netty.util.Timer;
   import io.netty.util.TimerTask;
   import lombok.extern.slf4j.Slf4j;
   
   import java.net.InetSocketAddress;
   import java.util.concurrent.CompletableFuture;
   import java.util.concurrent.TimeUnit;
   @Sharable//用来说明ChannelHandler是否可以在多个channel直接共享使用
   @Slf4j
   public abstract class ConnectionWatchdog extends ChannelInboundHandlerAdapter implements TimerTask ,ChannelHandlerHolder,CacheClearHandler{
    
    
    
       private final Bootstrap bootstrap;
       private final Timer timer;
       private final InetSocketAddress inetSocketAddress;
    
       private volatile boolean reconnect = true;
       private int attempts;
   
       private final CompletableFuture<Channel> completableFuture;
    
    
       public ConnectionWatchdog(Bootstrap bootstrap, Timer timer, InetSocketAddress inetSocketAddress, CompletableFuture<Channel> completableFuture, boolean reconnect) {
           this.bootstrap = bootstrap;
           this.timer = timer;
           this.inetSocketAddress = inetSocketAddress;
           this.reconnect = reconnect;
           this.completableFuture = completableFuture;
       }
    
       /**
        * channel链路每次active的时候，将其连接的次数重新☞ 0
        */
       @Override
       public void channelActive(ChannelHandlerContext ctx) throws Exception {
           log.info("当前链路已经激活了，重连尝试次数重新置为0");
           attempts = 0;
           ctx.fireChannelActive();
       }
    
       @Override
       public void channelInactive(ChannelHandlerContext ctx) throws Exception {
           log.info("链接关闭");
           if(reconnect){
               log.info("链接关闭，将进行重连");
               if (attempts < 12) {
                   attempts++;
                   log.info("重连次数:{}",attempts);
               }else{
                   //不在重连了
                   reconnect = false;
                   //连接失败 从 缓存中 去除
                   clear(inetSocketAddress);
               }
               //重连的间隔时间会越来越长
               int timeout = 2 << attempts;
               timer.newTimeout(this, timeout, TimeUnit.MILLISECONDS);
           }
           ctx.fireChannelInactive();
       }
    
       public void run(Timeout timeout) throws Exception {
           ChannelFuture future;
           //bootstrap已经初始化好了，只需要将handler填入就可以了
           synchronized (bootstrap) {
               bootstrap.handler(new ChannelInitializer<Channel>(){
                   @Override
                   protected void initChannel(Channel ch) throws Exception {
                       ch.pipeline().addLast(handlers());
                   }
               });
               future = bootstrap.connect(inetSocketAddress);
           }
           future.addListener(new ChannelFutureListener() {
               @Override
               public void operationComplete(ChannelFuture f) throws Exception {
                   if (f.isSuccess()){
                       //代表连接成功，将channel放入任务中
                       completableFuture.complete(f.channel());
                   }else {
                       completableFuture.completeExceptionally(future.cause());
                       //尝试重连
                       f.channel().pipeline().fireChannelInactive();
                   }
               }
           });
       }
    
   }
   ~~~

   ~~~java
   package com.mszlu.rpc.netty.handler.idle;
   
   import java.net.InetSocketAddress;
   
   public interface CacheClearHandler {
   
       /**
        * 清理缓存
        */
       void clear(InetSocketAddress inetSocketAddress);
   }
   
   ~~~

   

   1. 继承了ChannelInboundHandlerAdapter，说明它也是Handler，也对，作为一个检测对象，肯定会放在链路中，否则怎么检测
   2. 实现了2个接口，TimeTask，ChannelHandlerHolder
      1. `TimeTask`，我们就要写run方法，这应该是一个定时任务，这个定时任务做的事情应该是重连的工作
      2. `ChannelHandlerHolder`的接口，这个接口我们刚才说过是维护的所有的Handlers，因为在重连的时候需要获取Handlers
   3. bootstrap对象，重连的时候依旧需要这个对象
   4. 当链路断开的时候会触发channelInactive这个方法，也就说触发重连的导火索是从这边开始的

3. NettyClient改造

   ~~~java
   package com.mszlu.rpc.netty;
   
   import com.alibaba.nacos.api.naming.pojo.Instance;
   import com.alibaba.nacos.common.utils.RandomUtils;
   import com.mszlu.rpc.config.MsRpcConfig;
   import com.mszlu.rpc.constants.CompressTypeEnum;
   import com.mszlu.rpc.constants.MessageTypeEnum;
   import com.mszlu.rpc.constants.SerializationTypeEnum;
   import com.mszlu.rpc.exception.MsRpcException;
   import com.mszlu.rpc.factory.SingletonFactory;
   import com.mszlu.rpc.message.MsMessage;
   import com.mszlu.rpc.message.MsRequest;
   import com.mszlu.rpc.message.MsResponse;
   import com.mszlu.rpc.netty.codec.MsRpcDecoder;
   import com.mszlu.rpc.netty.codec.MsRpcEncoder;
   import com.mszlu.rpc.netty.handler.client.ChannelCache;
   import com.mszlu.rpc.netty.handler.client.MsNettyClientHandler;
   import com.mszlu.rpc.netty.handler.client.UnprocessedRequests;
   import com.mszlu.rpc.netty.handler.idle.ConnectionWatchdog;
   import com.mszlu.rpc.register.nacos.NacosTemplate;
   import io.netty.bootstrap.Bootstrap;
   import io.netty.channel.*;
   import io.netty.channel.nio.NioEventLoopGroup;
   import io.netty.channel.socket.SocketChannel;
   import io.netty.channel.socket.nio.NioSocketChannel;
   import io.netty.handler.logging.LogLevel;
   import io.netty.handler.logging.LoggingHandler;
   import io.netty.handler.timeout.IdleStateHandler;
   import io.netty.util.HashedWheelTimer;
   import lombok.extern.slf4j.Slf4j;
   
   import java.net.InetSocketAddress;
   import java.util.*;
   import java.util.concurrent.CompletableFuture;
   import java.util.concurrent.CopyOnWriteArraySet;
   import java.util.concurrent.TimeUnit;
   
   @Slf4j
   public class NettyClient implements MsClient {
       private final Bootstrap bootstrap;
       private final EventLoopGroup eventLoopGroup;
       private  UnprocessedRequests unprocessedRequests;
       private NacosTemplate nacosTemplate;
       private MsRpcConfig msRpcConfig;
   
       protected final HashedWheelTimer timer = new HashedWheelTimer();
   
       //读快 写慢 不适用于存取大量数据  并且写多的场景
       private static final Set<String> SERVICES= new CopyOnWriteArraySet<>();
   
       public NettyClient(){
           this.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);
           this.nacosTemplate = SingletonFactory.getInstance(NacosTemplate.class);
   
           eventLoopGroup = new NioEventLoopGroup();
           bootstrap = new Bootstrap();
   
   
           bootstrap.group(eventLoopGroup)
                   .channel(NioSocketChannel.class)
                   .handler(new LoggingHandler(LogLevel.INFO))
                   //超时时间设置
                   .option(ChannelOption.CONNECT_TIMEOUT_MILLIS,5000);
   //                .handler(new ChannelInitializer<SocketChannel>() {
   //                    @Override
   //                    protected void initChannel(SocketChannel ch) throws Exception {
   //                        //3s 没收到写请求，进行心跳检测
   //                        ch.pipeline().addLast(new IdleStateHandler(0, 3, 0, TimeUnit.SECONDS));
   //                        ch.pipeline ().addLast ( "decoder",new MsRpcDecoder() );
   //                        ch.pipeline ().addLast ( "encoder",new MsRpcEncoder());
   //                        ch.pipeline ().addLast ( "handler",new MsNettyClientHandler() );
   //
   //                    }
   //                });
       }
   
       public Object sendRequest(MsRequest msRequest,String host,int port) {
           //发送数据
           //1. 连接netty服务，获取channel
   //        InetSocketAddress inetSocketAddress = new InetSocketAddress(host, port);
           //通过注册中心获取主机和端口
           String serviceName = msRequest.getInterfaceName() + msRequest.getVersion();
           String ipAndPort = null;
           InetSocketAddress inetSocketAddress = null;
           if (!SERVICES.isEmpty()){
               //有缓存的服务提供者服务器，直接获取
               //随机获取一个
               int nextInt = RandomUtils.nextInt(0, SERVICES.size() - 1);
               Optional<String> optional = SERVICES.stream().skip(nextInt).findFirst();
               if (optional.isPresent()){
                   ipAndPort = optional.get();
                   String[] split = ipAndPort.split(",");
                   inetSocketAddress = new InetSocketAddress(split[0],Integer.parseInt(split[1]));
                   log.info("走了缓存的服务提供者地址，省去了连接nacos的过程...");
               }
           }
           if (inetSocketAddress == null){
               Instance oneHealthyInstance = null;
               try {
                   //根据组 进行获取健康实例，服务提供方和消费方 不在一个组内 无法获取实例
                   oneHealthyInstance = nacosTemplate.getOneHealthyInstance(serviceName,msRpcConfig.getNacosGroup());
               } catch (Exception e) {
                   throw new MsRpcException("没有获取到可用的服务提供者");
               }
               //从nacos获取实例后，将其缓存起来
               SERVICES.add(oneHealthyInstance.getIp()+","+oneHealthyInstance.getPort());
               //
               inetSocketAddress = new InetSocketAddress(oneHealthyInstance.getIp(), oneHealthyInstance.getPort());
           }
   
           //连接
           CompletableFuture<Channel> completableFuture = new CompletableFuture<>();
   
           final ConnectionWatchdog watchdog = new ConnectionWatchdog(bootstrap, timer, inetSocketAddress, completableFuture, true) {
   
               @Override
               public void clear(InetSocketAddress ia) {
                   SERVICES.remove(ia.getHostName()+","+ia.getPort());
                   log.info("链路检测狗 触发: 删除provider服务缓存成功...");
               }
   
               public ChannelHandler[] handlers() {
                   return new ChannelHandler[] {
                           this,
                           new IdleStateHandler(0, 3, 0, TimeUnit.SECONDS),
                           new MsRpcDecoder(),
                           new MsRpcEncoder(),
                           new MsNettyClientHandler()
                   };
               }
           };
           bootstrap.handler(new ChannelInitializer<SocketChannel>() {
               @Override
               protected void initChannel(SocketChannel ch) throws Exception {
                   ch.pipeline().addLast(watchdog.handlers());
               }
           });
           String finalIpAndPort = ipAndPort;
           bootstrap.connect(inetSocketAddress).addListener(new ChannelFutureListener() {
               @Override
               public void operationComplete(ChannelFuture future) throws Exception {
                   if (future.isSuccess()){
                       //代表连接成功，将channel放入任务中
                       completableFuture.complete(future.channel());
                   }else {
                       //连接失败 从 缓存中 去除
                       if (finalIpAndPort != null){
                           SERVICES.remove(finalIpAndPort);
                           log.info("删除provider服务缓存成功...");
                       }
                       completableFuture.completeExceptionally(future.cause());
                       throw new MsRpcException("连接服务器失败");
                   }
               }
           });
           //结果获取的任务
           CompletableFuture<MsResponse<Object>> resultFuture = new CompletableFuture<>();
           try {
               Channel channel = completableFuture.get();
   
               if (channel.isActive()){
                   //将任务 存起来，和请求id对应，便于后续读取到数据后，可以根据请求id，将任务标识完成
                   unprocessedRequests.put(msRequest.getRequestId(),resultFuture);
                   //构建发送的数据
                   MsMessage msMessage = MsMessage.builder()
                           .messageType(MessageTypeEnum.REQUEST.getCode())
                           .codec(SerializationTypeEnum.PROTOSTUFF.getCode())
                           .compress(CompressTypeEnum.GZIP.getCode())
                           .data(msRequest)
                           .build();
                   //请求,并添加监听
                   channel.writeAndFlush(msMessage).addListener(new ChannelFutureListener() {
                       @Override
                       public void operationComplete(ChannelFuture future) throws Exception {
                           if (future.isSuccess()){
                               //任务完成
                               log.info("发送数据成功:{}",msMessage);
                           }else{
                               //发送数据失败
                               future.channel().close();
                               //任务标识为完成 有异常
                               resultFuture.completeExceptionally(future.cause());
                               log.info("发送数据失败:",future.cause());
                           }
                       }
                   });
   
               }
   
           } catch (Exception e) {
               throw new MsRpcException("获取Channel失败",e);
           }
   
           return resultFuture;
       }
   
       public MsRpcConfig getMsRpcConfig() {
           return msRpcConfig;
       }
   
       public void setMsRpcConfig(MsRpcConfig msRpcConfig) {
           this.msRpcConfig = msRpcConfig;
       }
   }
   
   ~~~

   

4. 测试



## 3.3 缓存Channel

> 我们发现，实际上，在进行请求时，channel是进行重新连接生成的，并没有复用之前重连的channel

~~~java
package com.mszlu.rpc.netty.handler.client;


import io.netty.channel.Channel;
import lombok.extern.slf4j.Slf4j;

import java.net.InetSocketAddress;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
//channelCache...
@Slf4j
public class ChannelCache {

    private final Map<String, Channel> channelMap;

    public ChannelCache(){
        channelMap = new ConcurrentHashMap<>();
    }

    public Channel get(InetSocketAddress inetSocketAddress){
        //获取缓存中的channel
        String key = inetSocketAddress.toString();
        if (channelMap.containsKey(key)){
            Channel channel = channelMap.get(key);
            if (channel != null && channel.isActive()){
                return channel;
            }else{
                remove(inetSocketAddress);
            }
        }
        return null;
    }

    public void set(InetSocketAddress inetSocketAddress, Channel channel){
        //放入缓存
        log.info("有channel 放入缓存：{}",inetSocketAddress.toString());
        channelMap.put(inetSocketAddress.toString(),channel);
    }

    public void remove(InetSocketAddress inetSocketAddress){
        //从缓存移除
        log.info("移出缓存：{}",inetSocketAddress.toString());
        channelMap.remove(inetSocketAddress.toString());
    }
}

~~~



1. 将连接的代码 提取出来

   ~~~java
    private final ChannelCache channelCache;
   
       public NettyClient(){
           this.channelCache = SingletonFactory.getInstance(ChannelCache.class);
       }
   private Channel getChannel(InetSocketAddress inetSocketAddress, CompletableFuture<Channel> completableFuture) {
           Channel channel = channelCache.get(inetSocketAddress);
           if (channel == null){
               channel = doConnect(inetSocketAddress,completableFuture);
               channelCache.set(inetSocketAddress,channel);
           }
           return channel;
       }
   
       @SneakyThrows
       private Channel doConnect(InetSocketAddress inetSocketAddress, CompletableFuture<Channel> completableFuture) {
   
           bootstrap.connect(inetSocketAddress).addListener(new ChannelFutureListener() {
               @Override
               public void operationComplete(ChannelFuture future) throws Exception {
                   if (future.isSuccess()){
                       //代表连接成功，将channel放入任务中
                       completableFuture.complete(future.channel());
                   }else {
                       //连接失败 从 缓存中 去除
                       SERVICES.remove(inetSocketAddress.getHostName()+","+inetSocketAddress.getPort());
                       log.info("删除provider服务缓存成功...");
                       completableFuture.completeExceptionally(future.cause());
                       throw new MsRpcException("连接服务器失败");
                   }
               }
           });
   
           return completableFuture.get();
       }
   
   ~~~

2. sendRequest方法中，改变获取channel的方式

   ~~~java
    Channel channel = getChannel(inetSocketAddress,completableFuture);
   ~~~

   

3. 当重连失败，清除缓存

   ~~~java
    @Override
               public void clear(InetSocketAddress ia) {
                   SERVICES.remove(ia.getHostName()+","+ia.getPort());
                   channelCache.remove(ia);
                   log.info("链路检测狗 触发: 删除provider服务缓存成功...");
               }
   ~~~

   

4. 在重连成功后，将其放入缓存

   ~~~java
   package com.mszlu.rpc.netty.handler.idle;
    
   /**
    *
    * 重连检测狗，当发现当前的链路不稳定关闭之后，进行12次重连
    */
   import com.mszlu.rpc.exception.MsRpcException;
   import com.mszlu.rpc.factory.SingletonFactory;
   import com.mszlu.rpc.netty.handler.client.ChannelCache;
   import io.netty.bootstrap.Bootstrap;
   import io.netty.channel.*;
   import io.netty.channel.ChannelHandler.Sharable;
   import io.netty.util.Timeout;
   import io.netty.util.Timer;
   import io.netty.util.TimerTask;
   import lombok.extern.slf4j.Slf4j;
   
   import java.net.InetSocketAddress;
   import java.util.concurrent.CompletableFuture;
   import java.util.concurrent.TimeUnit;
   @Sharable//用来说明ChannelHandler是否可以在多个channel直接共享使用
   @Slf4j
   public abstract class ConnectionWatchdog extends ChannelInboundHandlerAdapter implements TimerTask ,ChannelHandlerHolder,CacheClearHandler{
    
    
    
       private final Bootstrap bootstrap;
       private final Timer timer;
       private final InetSocketAddress inetSocketAddress;
    
       private volatile boolean reconnect = true;
       private int attempts;
   
       private final ChannelCache channelCache;
    
    
       public ConnectionWatchdog(Bootstrap bootstrap, Timer timer, InetSocketAddress inetSocketAddress, boolean reconnect) {
           this.bootstrap = bootstrap;
           this.timer = timer;
           this.inetSocketAddress = inetSocketAddress;
           this.reconnect = reconnect;
           this.channelCache = SingletonFactory.getInstance(ChannelCache.class);
       }
    
       /**
        * channel链路每次active的时候，将其连接的次数重新☞ 0
        */
       @Override
       public void channelActive(ChannelHandlerContext ctx) throws Exception {
           log.info("当前链路已经激活了，重连尝试次数重新置为0");
           attempts = 0;
           ctx.fireChannelActive();
       }
    
       @Override
       public void channelInactive(ChannelHandlerContext ctx) throws Exception {
           log.info("链接关闭");
           if(reconnect){
               log.info("链接关闭，将进行重连");
               if (attempts < 12) {
                   attempts++;
                   log.info("重连次数:{}",attempts);
               }else{
                   //不在重连了
                   reconnect = false;
                   //连接失败 从 缓存中 去除
                   clear(inetSocketAddress);
               }
               //重连的间隔时间会越来越长
               int timeout = 2 << attempts;
               timer.newTimeout(this, timeout, TimeUnit.MILLISECONDS);
           }
           ctx.fireChannelInactive();
       }
    
       public void run(Timeout timeout) throws Exception {
           ChannelFuture future;
           //bootstrap已经初始化好了，只需要将handler填入就可以了
           synchronized (bootstrap) {
               bootstrap.handler(new ChannelInitializer<Channel>(){
                   @Override
                   protected void initChannel(Channel ch) throws Exception {
                       ch.pipeline().addLast(handlers());
                   }
               });
               future = bootstrap.connect(inetSocketAddress);
           }
           future.addListener(new ChannelFutureListener() {
               @Override
               public void operationComplete(ChannelFuture f) throws Exception {
                   if (f.isSuccess()){
                       //代表连接成功，将channel放入任务中
                       Channel channel = f.channel();
                       channelCache.set(inetSocketAddress,channel);
                   }else {
                       //尝试重连
                       f.channel().pipeline().fireChannelInactive();
                   }
               }
           });
       }
    
   }
   ~~~

   

5. 测试