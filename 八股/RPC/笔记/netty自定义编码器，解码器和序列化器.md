# 好处

编解码的过程进行封装，代码变得简洁易读，维护方便

内部实现消息头的加工，解决沾包问题

消息头加入messageType消息类型，对消息的读取机制有了进一步扩展

# 为什么要序列化为字节数组

网络通信中，数据只能以字节流形式进行传输。将对象序列化为字节数组后，能够通过网络传输，并在接收方反序列化为原始对象

字节数组是一种通用的数据表示形式，不依赖于特定语言或平台，

# 

| 原生序列化         | 简单、自动化               | 性能低、兼容性风险       | 本地存储、简单应用     |
| ------------------ | -------------------------- | ------------------------ | ---------------------- |
| Externalizable     | 高效、可控性强             | 代码复杂、易出错         | 自定义数据处理         |
| JSON/XML           | 可读、跨语言               | 性能低、类型信息可能丢失 | Web服务、API通信       |
| Protobuf/Avro/Kryo | 高性能、跨语言、Schema支持 | 学习成本高、需预定义格式 | 分布式系统、大数据处理 |

**选择建议**：

- **追求开发效率**：原生序列化或JSON。
- **需要高性能或跨语言**：Protobuf或Avro。
- **高度可控的二进制格式**：Externalizable或Kryo。



# 原生序列化

1、创建输出流，使用 ByteArrayOutputstream，在内存中创建一个动态缓冲区，用于存储序列化后的字节数据。
2.包装输出流，使用 0bjectoutputstream将对象包装 ByteArray0utputStream写入字节缓冲区。
3.序列化对象，调用 0bjectoutputstream.write0bject(obj)方法，触发对象的序列化。
4.转化为字节数组，使用 ByteArray0utputstream.toByteArray()获取缓冲区中的字节数据。
5.关闭流，关闭 0bject0utputStream和 ByteArrayOutputStream 。



1.创建输入流，将字节数组包装为字节输入流。使用 ByteArrayInputStream
2.包装输入流，使用 0bjectInputstream包装 ByteArrayInputStream，以支持反序列化。
3.反序列化对象，调用 0bjectInputstream.read0bject()方法，将字节流数据解析为 Java 对象,
4.关闭流，关闭 0bjectInputStream和ByteArrayInputStream 。





# json序列化



序列化：调用 `JSONObject.toJSONBytes(obj)` 方法，该方法使用 Fastjson 将对象转换为 JSON 格式的字节流。

Fastjson 具有高性能、易用性和较好的兼容性，能够快速将 Java 对象转换为 JSON 字符串或字节数组，并支持复杂对象的序列化与反序列化。此外，Fastjson 提供的 API 简洁，易于集成到我们的 RPC 框架中。





反序列化：分为request还是response





### 1. 为什么选择 Fastjson 进行序列化？

**参考答案：**
Fastjson 具有高性能、易用性和较好的兼容性，能够快速将 Java 对象转换为 JSON 字符串或字节数组，并支持复杂对象的序列化与反序列化。此外，Fastjson 提供的 API 简洁，易于集成到我们的 RPC 框架中。

### 2. 在反序列化过程中，为什么需要对参数进行类型校验和转换？

**参考答案：**
由于反序列化时，由于 JSON 格式数据的动态性，可能会导致某些参数在反序列化后其类型与预期不匹配。为确保 RPC 请求在远程调用时能够正确地传递参数类型，我们通过对每个参数进行 `isAssignableFrom` 检查，若类型不匹配，则使用 `JSONObject.toJavaObject` 方法进行类型转换。这种做法确保了反序列化后的参数类型与接口方法声明的类型一致，从而避免类型转换异常。

### 3. 解释一下 `isAssignableFrom` 方法的作用。

**参考答案：**
`isAssignableFrom` 方法用于判断一个类或接口是否可以被另一个类或接口赋值。在这个代码中，判断反序列化出来的参数对象的实际类型是否与预期的参数类型一致。如果不一致，说明需要进行类型转换以保证类型安全。

### 4. 你如何看待序列化器的扩展性？例如，支持其他序列化方式。

**参考答案：**
通过实现 `Serializer` 接口，可以很容易地扩展出其他序列化方式（例如 Protobuf、XML 或自定义二进制格式）。每种序列化方式只需要实现接口中的 `serialize`、`deserialize` 和 `getType` 方法。这样可以在运行时根据配置选择不同的序列化器，以适应不同的应用场景和性能要求。

### 5. 如果反序列化时出现错误，你如何处理？

**参考答案：**
在目前的实现中，如果遇到不支持的消息类型，会打印提示并抛出异常。对于生产环境，可以考虑引入更完善的异常处理机制，比如记录日志、返回错误码或进行降级处理，以保证系统的健壮性和容错性。





# 编码后的整体数据格式：

数据依次包含：

1. 消息类型（short）
2. 序列化方式（short）
3. 数据长度（int）
4. 数据内容（byte[]）



# 编码器参数：

`ChannelHandlerContext ctx`：上下文对象，提供通道相关操作。

`Object msg`：待编码的消息对象，可以是 `RpcRequest` 或 `RpcResponse`。

`ByteBuf out`：Netty 的字节缓冲区，用于写入编码后的数据



**关于编码器的设计**

- 问题：

   为什么在编码时要写入消息类型、序列化方式、数据长度以及数据内容？

  回答思路：

  - 消息类型可以帮助接收端判断当前数据是一个请求还是响应。
  - 序列化方式标识支持系统扩展，便于在不同序列化协议之间切换。
  - 数据长度字段用于解决 TCP 粘包/拆包问题，使得接收方能准确分割字节流。
  - 数据内容则是经过序列化后的实际对象数据。

**关于 Netty 与 ByteBuf**

- 问题：

   为什么使用 Netty 的 

  ```
  ByteBuf
  ```

   进行编码，而不是直接使用 Java 的 IO 流？

  回答思路：

  - `ByteBuf` 是 Netty 提供的高效、灵活的缓冲区管理类，它可以减少内存拷贝并提供丰富的 API 来处理网络数据。
  - 相比 Java 的 IO 流，Netty 能更好地支持异步和高并发场景。

**关于序列化器的设计**

- 问题：

   为什么要设计一个独立的序列化器接口？

  回答思路：

  - 独立的序列化器接口可以使系统解耦，支持多种序列化方案（如 JSON、Protobuf、XML 等），并且在运行时可以根据配置灵活选择。
  - 当业务需求或性能要求发生变化时，可以很容易地替换序列化实现，而不影响整体编码解码逻辑。





# 解码

## 解码器读取出哪些数据

**消息类型**——检查消息类型是否为请求或响应。如果不是，则打印提示信息并直接返回，避免对不支持的数据进行解码。

**序列化类型**——读取序列化方式的标识符（serializerType），并根据该标识符通过静态方法 `Serializer.getSerializerByCode()` 获取对应的序列化器实例。

​		如果无法获取到序列化器，则抛出异常，确保数据能被正确反序列化。

**消息的长度和数据**——从 `ByteBuf` 中读取一个整型值，表示后续序列化数据的字节长度。这个字段帮助解码器知道需要读取多少字节的数据，防止因粘包或拆包问题导致数据不完整。



**关于协议设计**

- **问题：** 为什么在解码时需要先读取消息类型、序列化方式和数据长度？
- 参考答案：
  - 消息类型用于区分数据是请求还是响应，确保解码和后续处理正确。
  - 序列化方式允许系统支持多种序列化协议，通过标识符动态选择序列化器，具有良好的扩展性。
  - 数据长度字段帮助解决 TCP 粘包/拆包问题，使解码器知道应该读取多少字节的数据，从而确保数据完整性。

**关于 ByteBuf 和 Netty 解码器**

- **问题：** 解释一下 Netty 的 ByteBuf 和 ByteToMessageDecoder 的作用？
- 参考答案：
  - ByteBuf 是 Netty 的数据缓冲区，提供高效的读写操作，能够避免传统 Java IO 中的数组拷贝问题。
  - ByteToMessageDecoder 是 Netty 提供的一个抽象类，用于处理流式数据的解码。它会自动处理 TCP 粘包和拆包问题，将字节流转换为消息对象传递给下一个 ChannelHandler。

**关于序列化器的选择**

- **问题：** 如何根据 serializerType 获取对应的序列化器？如果找不到该序列化器怎么办？
- 参考答案：
  - 代码中使用 `Serializer.getSerializerByCode(serializerType)` 根据传入的 serializerType 获取对应的序列化器实例。如果返回 null，则说明系统中没有注册这种类型的序列化器，程序会抛出异常来阻止后续错误的数据处理。
  - 这种设计使得系统具有扩展性，可以支持多种序列化方式，只需在序列化器注册中添加新的实现。

**异常处理**

- **问题：** 在解码过程中如果遇到异常或者数据格式不符合预期，你会如何处理？
- 参考答案：
  - 目前代码中对不支持的消息类型进行了简单的打印并返回；对于找不到序列化器则直接抛出 RuntimeException。在实际项目中，可以考虑记录详细的日志、返回错误码或者采取重试机制来增强系统的健壮性。

**数据安全和完整性**

- **问题：** 该解码器如何确保读取到的数据是完整的？
- 参考答案：
  - 解码器通过在协议中定义数据长度字段，先读取数据的长度，再根据这个长度读取具体的字节数据，从而确保数据的完整性。这种设计可以有效应对 TCP 传输中可能出现的拆包问题。







